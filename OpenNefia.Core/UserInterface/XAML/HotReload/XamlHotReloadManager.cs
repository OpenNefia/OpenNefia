using Avalonia.Metadata;
using HarmonyLib;
using Mono.Reflection;
using OpenNefia.Core.UI.Wisp;
using OpenNefia.Core.Utility;
using OpenNefia.XamlInjectors.CompilerExtensions;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Reflection.Emit;
using XamlX.Ast;
using XamlX.Emit;
using XamlX.IL;
using XamlX.Parsers;
using XamlX.Transform;
using XamlX.TypeSystem;
using Sre = System.Reflection.Emit;
using static OpenNefia.XamlInjectors.XamlCompiler;
using JetBrains.Annotations;
using OpenNefia.Core.Log;

namespace OpenNefia.Core.UserInterface.XAML.HotReload
{
    internal interface IXamlHotReloadManager
    {
        void Initialize();
        bool HotReloadXamlControl(Type controlType, string xamlPath);
    }

    internal sealed class XamlHotReloadManager : IXamlHotReloadManager
    {
        private Harmony _harmony;
        private SreTypeSystem _typeSystem = default!;
        private XamlLanguageTypeMappings _xamlLanguage = default!;
        private XamlXmlnsMappings _xmlnsMappings = default!;
        private XamlLanguageEmitMappings<IXamlILEmitter, XamlILNodeEmitResult> _emitConfig = default!;

        public XamlHotReloadManager()
        {
            _harmony = new Harmony("io.opennefia.wisp.hotreload");
        }

        public void Initialize()
        {
            _typeSystem = new SreTypeSystem();

            _xamlLanguage = new XamlLanguageTypeMappings(_typeSystem)
            {
                XmlnsAttributes =
                {
                    _typeSystem.GetType(typeof(XmlnsDefinitionAttribute)),
                },
                ContentAttributes =
                {
                    _typeSystem.GetType(typeof(ContentAttribute))
                },
                UsableDuringInitializationAttributes =
                {
                    _typeSystem.GetType(typeof(UsableDuringInitializationAttribute))
                },
                DeferredContentPropertyAttributes =
                {
                    _typeSystem.GetType(typeof(DeferredContentAttribute))
                },
            };

            _xmlnsMappings = XamlXmlnsMappings.Resolve(_typeSystem, _xamlLanguage);

            _emitConfig = new XamlLanguageEmitMappings<IXamlILEmitter, XamlILNodeEmitResult>
            {
                ContextTypeBuilderCallback = (b, c) => EmitNameScopeField(_xamlLanguage, _typeSystem, b, c)
            };
        }

        /// <summary>
        /// Gets the assembly references necessary to compile XAML for this assembly.
        /// These should have been already generated by the OpenNefia.XamlInjectors task.
        /// </summary>
        private string[] GetAssemblyReferences(Assembly assembly)
        {
            // TODO implement
            return File.ReadAllLines("C:/Users/yuno/build/OpenNefia.NET/OpenNefia.Core/obj/Debug/net6.0/XAML/references");
        }

        public bool HotReloadXamlControl(Type controlType, string xamlPath)
        {
            if (!typeof(WispControl).IsAssignableFrom(controlType))
            {
                throw new InvalidOperationException($"Type '{controlType}' does not inherit from {nameof(WispControl)}.");
            }

            if (!File.Exists(xamlPath))
            {
                throw new FileNotFoundException($"XAML file for {controlType} not found: {xamlPath}");
            }

            var containingAssembly = controlType.Assembly;
            var assemblyReferences = GetAssemblyReferences(containingAssembly);
            var xamlResource = new Resource(containingAssembly, controlType, xamlPath);

            if (controlType.GetMethod($"Populate:{xamlResource.Name}", BindingFlags.Static | BindingFlags.NonPublic) == null)
            {
                throw new InvalidOperationException($"Control type '{controlType}' was not generated from XAML (missing populate method)");
            }

            var transformerConfig = new TransformerConfiguration(
            _typeSystem,
            _typeSystem.GetAssembly(containingAssembly),
            _xamlLanguage,
            _xmlnsMappings,
            CustomValueConverter);

            var compiler = new OpenNefiaXamlILCompiler(transformerConfig, _emitConfig, true);

            var xaml = new StreamReader(new MemoryStream(xamlResource.FileContents)).ReadToEnd();
            var parsed = XDocumentXamlParser.Parse(xaml);

            var xamlClassType = GetClassTypeFromXaml(xamlResource, parsed);

            if (xamlClassType.FullName != controlType.FullName)
            {
                throw new InvalidDataException($"Class type mismatch: passed={controlType.FullName}, inXaml={xamlClassType.FullName}");
            }

            compiler.Transform(parsed);

            var populateMethod = CompileNewPopulateMethod(compiler, xamlResource, parsed);
            var newIl = GetCodeInstructions(populateMethod);
            UpdatePopulateMethodIL(controlType, populateMethod, newIl);

            Logger.InfoS("wisp.hotreload", $"Hot reloaded XAML of {controlType}.");

            return true;
        }

        #region XAML Compilation

        /// <summary>
        /// Compiles the new XAML to a method body holding the new control initialization code.
        /// </summary>
        private MethodInfo CompileNewPopulateMethod(OpenNefiaXamlILCompiler compiler, IResource xamlResource, XamlDocument parsed)
        {
            // Create a dummy module to hold the new populate method.
            var module = AssemblyBuilder
                .DefineDynamicAssembly(
                    new AssemblyName($"{nameof(XamlHotReloadManager)}_Assembly"),
                    AssemblyBuilderAccess.RunAndCollect)
                .DefineDynamicModule($"{nameof(XamlHotReloadManager)}_Module");

            // First define the "context" type, which the XamlX compiler requires.
            var sreContextTypeBuilder = module
                .DefineType("XamlIlContext",
                    TypeAttributes.Class | TypeAttributes.Public);
            var xamlContextTypeBuilder = _typeSystem.CreateTypeBuilder(sreContextTypeBuilder);
            var contextClass = XamlILContextDefinition.GenerateContextClass(xamlContextTypeBuilder, _typeSystem, _xamlLanguage, _emitConfig);

            // Next, define a dummy type that will hold the new body of the autogenerated
            // "populate" method that initializes controls and set properties, etc.
            // This method body is what we're going to replace the current class's with.
            var sreDummyTypeBuilder = module
                .DefineType(
                    "PopulateMethodHolderDummy",
                    TypeAttributes.Class | TypeAttributes.Public);
            var xamlDummyTypeBuilder = _typeSystem.CreateTypeBuilder(sreDummyTypeBuilder);

            // The method name is the same as the one generated by OpenNefia.XamlInjectors.
            var populateName = $"Populate:{xamlResource.Name}";
            var populateMethod = compiler.DefinePopulateMethod(xamlDummyTypeBuilder, parsed, populateName, isPublic: false);

            compiler.Compile(parsed, contextClass,
                populateMethod,
                buildMethod: null,
                namespaceInfoBuilder: null,
                createClosure: null,
                createDelegateType: (closureName, closureBaseType, emitter) =>
                    xamlContextTypeBuilder.DefineSubType(closureBaseType, closureName, false),
                xamlResource.Uri,
                xamlResource
            );

            var compiledPopulateMethod = sreDummyTypeBuilder.CreateTypeInfo()!.DeclaredMethods
                .Where(m => m.Name == populateName).First();

            return compiledPopulateMethod;
        }

        private IXamlType GetClassTypeFromXaml(IResource res, XamlDocument parsed)
        {
            var initialRoot = (XamlAstObjectNode)parsed.Root;

            // Look for an unnamespaced "Class='<...>'" directive (we do not use the Xaml2006 namespace).
            var property = initialRoot.Children.OfType<XamlAstXamlPropertyValueNode>()
                .FirstOrDefault(p => p.Property is XamlAstNamePropertyReference namedProperty && namedProperty.Name == "Class");
            string classname;
            if (property != null && property.Values[0] is XamlAstTextNode tn)
            {
                classname = tn.Text;
            }
            else
            {
                classname = res.Name.Replace(".xaml", "");
            }

            var classType = _typeSystem.FindType(classname);
            if (classType == null)
                throw new Exception($"Unable to find type '{classname}'");
            return classType;
        }

        private static bool CustomValueConverter(
            AstTransformationContext context,
            IXamlAstValueNode node,
            IXamlType type,
            [NotNullWhen(true)] out IXamlAstValueNode? result)
        {
            if (!(node is XamlAstTextNode textNode))
            {
                result = null;
                return false;
            }

            var text = textNode.Text;
            var types = context.GetOpenNefiaTypes();

            if (Parsing.TryConvert(context, node, text, type, types, out result))
            {
                return true;
            }

            result = null;
            return false;
        }

        #endregion

        #region IL Patching

        private static Sre.Label MakeLabel(int labelIndex)
        {
            var constructor = typeof(Sre.Label).GetConstructor(
                BindingFlags.Instance | BindingFlags.NonPublic,
                null, new Type[] { typeof(int) }, null)!;

            return (Sre.Label)constructor.Invoke(new object[] { labelIndex });
        }

        /// <summary>
        /// Converts a method body into a Harmony-compatible bytecode format.
        /// </summary>
        private List<CodeInstruction> GetCodeInstructions(MethodInfo method)
        {
            var monoInstructions = method.GetInstructions();
            var harmonyInstructions = monoInstructions.Select(i => new CodeInstruction(i.OpCode, i.Operand)).ToList();
            ConvertLabels(monoInstructions, harmonyInstructions);

            return harmonyInstructions;
        }

        /// <summary>
        /// Converts IL labels from Mono.Reflection to System.Reflection.Emit.
        /// </summary>
        private static void ConvertLabels(IList<Instruction> monoInstructions, List<CodeInstruction> harmonyInstructions)
        {
            var lookup = new Dictionary<int, int>();
            var i = 0;
            foreach (var inst in monoInstructions)
            {
                lookup[inst.Offset] = i;
            }

            var labelLookup = new Dictionary<int, Label>();
            var labelIndex = 0;
            foreach (var instruction in harmonyInstructions)
            {
                // Check for Mono.Reflection instruction references and convert them to SRE labels.
                if (instruction.operand is Mono.Reflection.Instruction monoInst)
                {
                    var label = labelLookup.GetValueOrInsert(monoInst.Offset, () =>
                    {
                        var l = MakeLabel(labelIndex);
                        labelIndex += 1;
                        return l;
                    });

                    var harmonyInst = harmonyInstructions[lookup[monoInst.Offset]];
                    harmonyInst.labels.Add(label);
                    instruction.operand = label;
                }
            }
        }

        /// <summary>
        /// Runs Harmony to patch the XAML populate method on the control.
        /// </summary>
        private void UpdatePopulateMethodIL(Type controlType, MethodInfo populateMethod, List<CodeInstruction> newMethodBody)
        {
            XamlTranspilerPatch.NewPopulateMethodBody = newMethodBody;

            var original = controlType.GetMethod(populateMethod.Name, BindingFlags.NonPublic | BindingFlags.Static);

            _harmony.Patch(original, transpiler: XamlTranspilerPatch.TranspilerMethod);
        }

        /// <summary>
        /// Transpiler class used by Harmony.
        /// </summary>
        private static class XamlTranspilerPatch
        {
            public static IEnumerable<CodeInstruction> NewPopulateMethodBody { get; set; } = default!;

            public static HarmonyMethod TranspilerMethod =>
                new HarmonyMethod(typeof(XamlTranspilerPatch)
                    .GetMethod(nameof(Transpiler), BindingFlags.NonPublic | BindingFlags.Static));

            [UsedImplicitly]
            static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)
            {
                return NewPopulateMethodBody!;
            }
        }

        #endregion

    }
}
